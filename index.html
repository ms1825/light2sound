    <script>
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const overlayCtx = overlay.getContext('2d');
        const proc = document.getElementById('proc');
        const ctx = proc.getContext('2d', { willReadFrequently: true });
        const fpsDisp = document.getElementById('fps');
        
        let audioCtx;
        const synths = [];
        // Frequencies for the Tonal parts (Bass/Mids)
        const freqs = [55, 110, 220]; // A1, A2, A3

        let lastTime = 0;
        let frames = 0;

        // --- NEW: White Noise Generator Helper ---
        function createNoiseBuffer(ctx) {
            const bufferSize = ctx.sampleRate * 2; // 2 seconds of noise
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                // Generate random noise between -1 and 1
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('status').innerText = "Running Vocoder...";

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const noiseBuffer = createNoiseBuffer(audioCtx);

            // Setup 5 Channels
            for(let i=0; i<5; i++) {
                const gain = audioCtx.createGain();
                gain.gain.value = 0;
                gain.connect(audioCtx.destination);

                let node;

                // CHANNELS 0, 1, 2: Tonal (Robot Voice)
                if (i < 3) {
                    node = audioCtx.createOscillator();
                    node.type = 'sawtooth'; // Sawtooth is best for "Voice" simulation
                    node.frequency.value = freqs[i];
                    node.start();
                } 
                // CHANNELS 3, 4: Noise (Consonants S/T/K)
                else {
                    node = audioCtx.createBufferSource();
                    node.buffer = noiseBuffer;
                    node.loop = true;
                    // Pitch the noise slightly differently for variety
                    node.playbackRate.value = i === 3 ? 0.8 : 1.2; 
                    node.start();
                }

                node.connect(gain);
                synths.push({ node, gain });
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, frameRate: { ideal: 60 } }, audio: false
                });
                video.srcObject = stream;
                requestAnimationFrame(loop);
            } catch(e) {
                alert("Camera Error: " + e.message);
            }
        });

        function loop(time) {
            requestAnimationFrame(loop);

            // FPS Counter
            if(time - lastTime >= 1000) {
                fpsDisp.innerText = `FPS: ${frames}`;
                frames = 0;
                lastTime = time;
            }
            frames++;

            if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

            if (proc.width !== video.videoWidth) {
                proc.width = video.videoWidth;
                proc.height = video.videoHeight;
                overlay.width = video.videoWidth;
                overlay.height = video.videoHeight;
            }

            ctx.drawImage(video, 0, 0);

            const w = proc.width;
            const h = proc.height;
            const zoneW = w / 7; 
            const startX = zoneW; 
            const sampleY = h / 2;
            const sampleH = h / 4;

            overlayCtx.clearRect(0, 0, w, h);
            overlayCtx.strokeStyle = "red";
            overlayCtx.lineWidth = 4;

            for(let i=0; i<5; i++) {
                const x = startX + (i * zoneW);
                const y = sampleY - (sampleH/2);
                
                overlayCtx.strokeRect(x, y, zoneW*0.8, sampleH);

                const imgData = ctx.getImageData(x + (zoneW*0.4), y, 2, sampleH).data;
                
                let total = 0;
                for(let p=0; p<imgData.length; p+=4) {
                    total += imgData[p] + imgData[p+1] + imgData[p+2];
                }
                
                const brightness = total / ((imgData.length/4) * 765);

                // FASTER RESPONSE: Changed smoothing from 0.1 to 0.05
                // We need the "S" sounds to snap on/off instantly
                const smooth = i >= 3 ? 0.02 : 0.08; 
                
                synths[i].gain.gain.setTargetAtTime(brightness * 2.5, audioCtx.currentTime, smooth);
            }
        }
    </script>


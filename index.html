<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body { background: #222; color: #fff; font-family: sans-serif; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; margin: 0; }
        #qrcode { background: white; padding: 20px; border: 5px solid #444; margin-top: 20px; }
        #status { font-size: 20px; margin-top: 20px; color: #0f0; max-width: 80%; word-wrap: break-word; }
        button { padding: 15px 30px; font-size: 18px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 5px; }
    </style>
</head>
<body>

    <h2>Digital Audio Transmitter (Header Fix)</h2>
    <div id="qrcode"></div>
    <div id="status">Ready to Stream</div>
    <button id="btn" onclick="initAudio()">START OPUS STREAM</button>

    <script>
        const qrContainer = document.getElementById("qrcode");
        const status = document.getElementById("status");
        let qr = new QRCode(qrContainer, { width: 350, height: 350, correctLevel: QRCode.CorrectLevel.L });
        
        // CONFIG
        const RECORD_INTERVAL = 800; // Increased to 800ms to reduce overhead
        const QR_SIZE = 350;        // Increased Payload size for efficiency
        const FPS = 15;             
        const REDUNDANCY = 2;       // Lower redundancy to catch up with speed

        let audioStream;
        let packetQueue = [];
        let chunkCounter = 0;

        async function initAudio() {
            const btn = document.getElementById('btn');
            try {
                btn.style.display = 'none';
                status.innerText = "Select 'Share Audio' in popup...";

                const screenStream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: true });
                const audioTracks = screenStream.getAudioTracks();
                
                if (audioTracks.length === 0) throw new Error("No Audio Track! Check 'Share System Audio'.");

                // Clean Audio Stream
                audioStream = new MediaStream([audioTracks[0]]);
                
                status.innerText = "Transmitting...";
                
                // Start the Loop
                recordSlice();
                startQRLoop();

            } catch (err) {
                console.error(err);
                status.innerText = "ERROR: " + err.message;
                btn.style.display = 'block';
            }
        }

        // The "Stop/Start" Loop
        function recordSlice() {
            // Create a NEW recorder for every slice
            const recorder = new MediaRecorder(audioStream);
            const chunks = [];

            recorder.ondataavailable = e => chunks.push(e.data);
            
            recorder.onstop = () => {
                // Combine parts (usually just one) into a Blob
                const blob = new Blob(chunks, { type: 'audio/webm;codecs=opus' });
                processAudioBlob(blob);
            };

            // Start, wait, stop
            recorder.start();
            setTimeout(() => {
                if(recorder.state === "recording") recorder.stop();
                recordSlice(); // Recursively call next slice
            }, RECORD_INTERVAL);
        }

        function processAudioBlob(blob) {
            chunkCounter++;
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = () => {
                const base64data = reader.result.split(',')[1]; 
                const totalPackets = Math.ceil(base64data.length / QR_SIZE);
                
                // Optimization: If clip is silent/empty, it's very small. Skip it.
                if (base64data.length < 100) return; 

                for (let i = 0; i < totalPackets; i++) {
                    const chunk = base64data.substr(i * QR_SIZE, QR_SIZE);
                    // ID-Part/Total|Data
                    const payload = `${chunkCounter}-${i + 1}/${totalPackets}|${chunk}`;
                    
                    for(let r=0; r<REDUNDANCY; r++) {
                        packetQueue.push(payload);
                    }
                }
            };
        }

        function startQRLoop() {
            setInterval(() => {
                if (packetQueue.length > 0) {
                    const data = packetQueue.shift();
                    qr.clear();
                    qr.makeCode(data);
                    
                    const info = data.split('|')[0];
                    status.innerText = `Q: ${packetQueue.length} | Sending: ${info}`;
                } else {
                    status.innerText = "Buffering...";
                }
            }, 1000 / FPS);
        }
    </script>
</body>
</html>

